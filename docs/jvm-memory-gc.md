# JVM, Memory Model & Garbage Collection

Understanding the JVM internals is crucial for Java interviews—especially for senior positions. This guide covers memory architecture, class loading, garbage collection, and performance tuning.

---

## Definitions

- **JVM (Java Virtual Machine)**: An abstract computing machine that provides a runtime environment to execute Java bytecode. It handles memory management, security, and cross-platform compatibility.

- **Bytecode**: Platform-independent intermediate code generated by the Java compiler (`.class` files) that the JVM interprets or compiles to native code.

- **Class Loader**: Component responsible for loading class files into the JVM. Follows a hierarchical delegation model (Bootstrap → Platform → Application).

- **Heap**: Shared memory area where all objects are allocated. Managed by the garbage collector. Divided into generations (Young, Old).

- **Stack**: Per-thread memory for method execution. Stores local variables, method parameters, and return addresses. Each method call creates a stack frame.

- **Garbage Collection (GC)**: Automatic memory reclamation process that identifies and removes objects no longer reachable from GC roots.

- **Generational GC**: Strategy based on the observation that most objects die young. Separates heap into Young Generation (frequent, fast GC) and Old Generation (infrequent, slower GC).

- **Stop-the-World (STW)**: A GC pause where all application threads are stopped. Necessary for certain GC phases to ensure consistent state.

- **JIT Compiler**: Just-In-Time compiler that converts "hot" bytecode into optimized native machine code at runtime for better performance.

- **Metaspace**: Native memory area (since Java 8) storing class metadata, replacing the old PermGen space. Can grow dynamically.

- **GC Roots**: Starting points for garbage collection reachability analysis. Include local variables, static fields, active threads, and JNI references.

---

## Illustrations

### JVM Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            JVM ARCHITECTURE                              │
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                   CLASS LOADER SUBSYSTEM                            │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────────┐  │ │
│  │  │   Loading    │→ │   Linking    │→ │    Initialization        │  │ │
│  │  │              │  │ •Verify      │  │ Execute static blocks    │  │ │
│  │  │ Find & read  │  │ •Prepare     │  │ & initializers           │  │ │
│  │  │ .class file  │  │ •Resolve     │  │                          │  │ │
│  │  └──────────────┘  └──────────────┘  └──────────────────────────┘  │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                 │                                        │
│                                 ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                     RUNTIME DATA AREAS                              │ │
│  │                                                                      │ │
│  │  ┌─────────────────────┐  ┌─────────────────────────────────────┐  │ │
│  │  │    METHOD AREA      │  │              HEAP                    │  │ │
│  │  │    (Metaspace)      │  │  ┌───────────────┬───────────────┐  │  │ │
│  │  │ • Class metadata    │  │  │    Young      │     Old       │  │  │ │
│  │  │ • Method bytecode   │  │  │  Generation   │  Generation   │  │  │ │
│  │  │ • Constant pool     │  │  │               │               │  │  │ │
│  │  │ • Runtime constants │  │  │ [Eden][S0][S1]│   [Tenured]   │  │  │ │
│  │  │                     │  │  └───────────────┴───────────────┘  │  │ │
│  │  │    (Shared)         │  │           (Shared)                  │  │ │
│  │  └─────────────────────┘  └─────────────────────────────────────┘  │ │
│  │                                                                      │ │
│  │  Per-Thread Areas:                                                  │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────────┐ │ │
│  │  │ PC Register │  │  JVM Stack  │  │  Native Method Stack        │ │ │
│  │  │             │  │ [Frame 3]   │  │                             │ │ │
│  │  │ Address of  │  │ [Frame 2]   │  │  For native (C/C++)         │ │ │
│  │  │ current     │  │ [Frame 1]   │  │  method calls               │ │ │
│  │  │ instruction │  │ [main()]    │  │                             │ │ │
│  │  └─────────────┘  └─────────────┘  └─────────────────────────────┘ │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                 │                                        │
│                                 ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                       EXECUTION ENGINE                              │ │
│  │  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐  │ │
│  │  │   Interpreter   │ │  JIT Compiler   │ │ Garbage Collector   │  │ │
│  │  │                 │ │                 │ │                     │  │ │
│  │  │ Execute byte    │ │ Compile hot     │ │ Reclaim unused      │  │ │
│  │  │ code line by    │ │ code to native  │ │ memory from heap    │  │ │
│  │  │ line            │ │ for speed       │ │                     │  │ │
│  │  └─────────────────┘ └─────────────────┘ └─────────────────────┘  │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                 │                                        │
│                                 ▼                                        │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │               Native Method Interface (JNI)                         │ │
│  │          (Interface to native libraries: C, C++, etc.)              │ │
│  └────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
```

### Heap Memory Structure

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         HEAP MEMORY STRUCTURE                            │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                           HEAP                                     │  │
│  │                                                                    │  │
│  │  ┌─────────────────────────────────┐  ┌─────────────────────────┐ │  │
│  │  │        YOUNG GENERATION         │  │    OLD GENERATION       │ │  │
│  │  │  (Minor GC - fast, frequent)    │  │   (Major GC - slow)     │ │  │
│  │  │                                 │  │                         │ │  │
│  │  │  ┌──────────────────────────┐   │  │  ┌───────────────────┐  │ │  │
│  │  │  │         EDEN             │   │  │  │                   │  │ │  │
│  │  │  │  • New objects created   │   │  │  │     TENURED       │  │ │  │
│  │  │  │  • Fast allocation       │   │  │  │                   │  │ │  │
│  │  │  │  • Most objects die here │   │  │  │  • Long-lived     │  │ │  │
│  │  │  └──────────────────────────┘   │  │  │    objects        │  │ │  │
│  │  │                                 │  │  │                   │  │ │  │
│  │  │  ┌───────────┐ ┌───────────┐   │  │  │  • Promoted from  │  │ │  │
│  │  │  │    S0     │ │    S1     │   │  │  │    survivor after │  │ │  │
│  │  │  │  (From)   │ │   (To)    │   │  │  │    threshold      │  │ │  │
│  │  │  │           │ │           │   │  │  │                   │  │ │  │
│  │  │  │ Survivors │ │ Survivors │   │  │  │  • Large objects  │  │ │  │
│  │  │  │ from last │ │ (empty    │   │  │  │    directly here  │  │ │  │
│  │  │  │ GC cycle  │ │  until    │   │  │  │                   │  │ │  │
│  │  │  │           │ │  next GC) │   │  │  │                   │  │ │  │
│  │  │  └───────────┘ └───────────┘   │  │  └───────────────────┘  │ │  │
│  │  │       SURVIVOR SPACES          │  │                         │ │  │
│  │  │  (Objects surviving Minor GC)  │  │                         │ │  │
│  │  └─────────────────────────────────┘  └─────────────────────────┘ │  │
│  │                                                                    │  │
│  │  Default ratios:                                                   │  │
│  │  • Young:Old = 1:2 (-XX:NewRatio=2)                               │  │
│  │  • Eden:S0:S1 = 8:1:1 (-XX:SurvivorRatio=8)                       │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  Object Lifecycle:                                                      │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  1. Object created in Eden                                        │  │
│  │              │                                                     │  │
│  │              ▼ (Minor GC)                                         │  │
│  │  2. Survives? → Move to Survivor (age++)                         │  │
│  │              │                                                     │  │
│  │              ▼ (age > threshold, default 15)                      │  │
│  │  3. Promoted to Old Generation                                    │  │
│  │              │                                                     │  │
│  │              ▼ (Major GC when Old fills up)                       │  │
│  │  4. Eventually collected or causes Full GC                        │  │
│  └──────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

### Stack vs Heap

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         STACK vs HEAP                                    │
│                                                                          │
│   STACK (Per Thread)                     HEAP (Shared)                  │
│   ┌─────────────────────┐               ┌───────────────────────────┐  │
│   │                     │               │                           │  │
│   │  ┌───────────────┐  │               │  ┌───────────────────┐    │  │
│   │  │ method3()     │  │     ref       │  │   Person Object   │    │  │
│   │  │ int z = 30    │  │───────────────┼──│   name: "Alice"   │    │  │
│   │  │ Person p      │──┼───────────────┼──│   age: 30         │    │  │
│   │  └───────────────┘  │               │  └───────────────────┘    │  │
│   │                     │               │                           │  │
│   │  ┌───────────────┐  │               │  ┌───────────────────┐    │  │
│   │  │ method2()     │  │     ref       │  │   String "Hello"  │    │  │
│   │  │ String s      │──┼───────────────┼──│   (String Pool)   │    │  │
│   │  │ int y = 20    │  │               │  └───────────────────┘    │  │
│   │  └───────────────┘  │               │                           │  │
│   │                     │               │  ┌───────────────────┐    │  │
│   │  ┌───────────────┐  │     ref       │  │   int[] array     │    │  │
│   │  │ method1()     │  │───────────────┼──│   [1, 2, 3, 4, 5] │    │  │
│   │  │ int[] arr     │──┼───────────────┘  └───────────────────┘    │  │
│   │  │ int x = 10    │  │               │                           │  │
│   │  └───────────────┘  │               │                           │  │
│   │                     │               │  Objects, arrays, and     │  │
│   │  ┌───────────────┐  │               │  class instances live     │  │
│   │  │ main()        │  │               │  here. Managed by GC.     │  │
│   │  │ double d=1.5  │  │               │                           │  │
│   │  └───────────────┘  │               │                           │  │
│   └─────────────────────┘               └───────────────────────────┘  │
│                                                                          │
│   STACK                                  HEAP                           │
│   ─────                                  ────                           │
│   • Per thread (isolated)                • Shared across threads        │
│   • Stores primitives directly           • Stores objects               │
│   • Stores references to heap            • Garbage collected            │
│   • LIFO (Last In First Out)             • Dynamic allocation           │
│   • Fixed size (-Xss)                    • Growable (-Xms/-Xmx)         │
│   • Fast allocation/deallocation         • Slower (GC overhead)         │
│   • StackOverflowError if full           • OutOfMemoryError if full     │
│   • Auto cleanup on method exit          • GC cleans unreachable        │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Object Layout in Memory

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    OBJECT LAYOUT IN MEMORY                               │
│                                                                          │
│   Every Java object has this structure:                                 │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                     OBJECT HEADER                                │   │
│   │  ┌─────────────────────────────────────────────────────────────┐│   │
│   │  │              MARK WORD (8 bytes on 64-bit)                   ││   │
│   │  │  ┌─────────────────────────────────────────────────────────┐││   │
│   │  │  │ • hashCode (25 bits)                                    │││   │
│   │  │  │ • GC age (4 bits) - how many GCs survived              │││   │
│   │  │  │ • Lock state (2 bits) - biased/thin/fat                │││   │
│   │  │  │ • Thread ID for biased locking                         │││   │
│   │  │  └─────────────────────────────────────────────────────────┘││   │
│   │  └─────────────────────────────────────────────────────────────┘│   │
│   │  ┌─────────────────────────────────────────────────────────────┐│   │
│   │  │         CLASS POINTER (4 bytes with compressed oops)        ││   │
│   │  │  Points to class metadata in Metaspace                      ││   │
│   │  └─────────────────────────────────────────────────────────────┘│   │
│   │  ┌─────────────────────────────────────────────────────────────┐│   │
│   │  │         ARRAY LENGTH (4 bytes - arrays only)                ││   │
│   │  └─────────────────────────────────────────────────────────────┘│   │
│   └─────────────────────────────────────────────────────────────────┘   │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                     INSTANCE DATA                                │   │
│   │  • Fields ordered by size (longs/doubles, ints, shorts, bytes)  │   │
│   │  • Padding added for alignment (8-byte boundaries)              │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                     PADDING                                      │   │
│   │  • Ensure object size is multiple of 8 bytes                    │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   Example: Empty object size                                            │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │ Object o = new Object();                                        │    │
│   │                                                                 │    │
│   │ Header:  8 (mark) + 4 (class pointer) = 12 bytes               │    │
│   │ Padding: 4 bytes (to reach 16, multiple of 8)                  │    │
│   │ Total:   16 bytes minimum                                       │    │
│   └────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
```

### Class Loader Hierarchy

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    CLASS LOADER HIERARCHY                                │
│                                                                          │
│                    ┌─────────────────────────┐                          │
│                    │  Bootstrap ClassLoader  │                          │
│                    │  (Native code in JVM)   │                          │
│                    │                         │                          │
│                    │  Loads:                 │                          │
│                    │  • java.lang.*          │                          │
│                    │  • java.util.*          │                          │
│                    │  • Core Java classes    │                          │
│                    │  From: rt.jar, JDK libs │                          │
│                    └───────────┬─────────────┘                          │
│                                │                                         │
│                    ┌───────────▼─────────────┐                          │
│                    │  Platform ClassLoader   │                          │
│                    │  (ExtClassLoader)       │                          │
│                    │                         │                          │
│                    │  Loads:                 │                          │
│                    │  • Extension classes    │                          │
│                    │  From: jre/lib/ext      │                          │
│                    └───────────┬─────────────┘                          │
│                                │                                         │
│                    ┌───────────▼─────────────┐                          │
│                    │  Application ClassLoader│                          │
│                    │  (System ClassLoader)   │                          │
│                    │                         │                          │
│                    │  Loads:                 │                          │
│                    │  • Application classes  │                          │
│                    │  From: -classpath, -cp  │                          │
│                    └───────────┬─────────────┘                          │
│                                │                                         │
│                    ┌───────────▼─────────────┐                          │
│                    │   Custom ClassLoaders   │                          │
│                    │                         │                          │
│                    │  • Web app classloaders │                          │
│                    │  • OSGi bundle loaders  │                          │
│                    │  • Hot deployment       │                          │
│                    └─────────────────────────┘                          │
│                                                                          │
│   PARENT DELEGATION MODEL:                                              │
│   ┌──────────────────────────────────────────────────────────────────┐ │
│   │                                                                   │ │
│   │   loadClass("com.example.MyClass")                               │ │
│   │        │                                                          │ │
│   │        ▼                                                          │ │
│   │   1. Check if already loaded → return if found                   │ │
│   │        │                                                          │ │
│   │        ▼                                                          │ │
│   │   2. Delegate to PARENT first                                    │ │
│   │        │                                                          │ │
│   │        ├──▶ Parent asks ITS parent, and so on...                 │ │
│   │        │    (Bootstrap tried first)                              │ │
│   │        │                                                          │ │
│   │        ▼                                                          │ │
│   │   3. If parent can't load → try to load ourselves                │ │
│   │        │                                                          │ │
│   │        ▼                                                          │ │
│   │   4. If still not found → ClassNotFoundException                 │ │
│   │                                                                   │ │
│   │   WHY parent-first?                                              │ │
│   │   • Security: Core classes can't be spoofed                      │ │
│   │   • Consistency: Same class = same loader                        │ │
│   │   • No duplicates: Class loaded once                             │ │
│   │                                                                   │ │
│   └──────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
```

### Garbage Collection Process

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    GARBAGE COLLECTION PROCESS                            │
│                                                                          │
│   STEP 1: IDENTIFY GC ROOTS                                             │
│   ┌──────────────────────────────────────────────────────────────────┐ │
│   │  GC Roots (Starting points for reachability):                    │ │
│   │  • Local variables on thread stacks                              │ │
│   │  • Static fields of loaded classes                               │ │
│   │  • Active threads                                                │ │
│   │  • JNI references                                                │ │
│   └──────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│   STEP 2: MARK REACHABLE OBJECTS                                        │
│   ┌──────────────────────────────────────────────────────────────────┐ │
│   │                                                                   │ │
│   │   GC Root                                                        │ │
│   │      │                                                            │ │
│   │      ▼                                                            │ │
│   │   ┌─────┐      ┌─────┐      ┌─────┐                              │ │
│   │   │  A  │─────▶│  B  │─────▶│  C  │   ← Reachable (MARKED)      │ │
│   │   └─────┘      └─────┘      └─────┘                              │ │
│   │                                                                   │ │
│   │                ┌─────┐      ┌─────┐                              │ │
│   │                │  D  │─────▶│  E  │   ← Unreachable (GARBAGE)   │ │
│   │                └─────┘      └─────┘                              │ │
│   │                                                                   │ │
│   └──────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│   STEP 3: SWEEP/COMPACT                                                 │
│   ┌──────────────────────────────────────────────────────────────────┐ │
│   │                                                                   │ │
│   │   Before:  [A][D][B][E][C][free][free]                          │ │
│   │                                                                   │ │
│   │   After Sweep: [A][free][B][free][C][free][free]                │ │
│   │   (D and E removed, memory fragmented)                          │ │
│   │                                                                   │ │
│   │   After Compact: [A][B][C][free][free][free][free]              │ │
│   │   (Live objects moved together, contiguous free space)          │ │
│   │                                                                   │ │
│   └──────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│   GC ALGORITHMS:                                                        │
│   ┌──────────────────────────────────────────────────────────────────┐ │
│   │                                                                   │ │
│   │   MARK-SWEEP:            MARK-SWEEP-COMPACT:    COPYING:         │ │
│   │   ┌─────────────┐        ┌─────────────┐        ┌─────┬─────┐   │ │
│   │   │[A][ ][B][ ]│        │[A][B][C][ ]│        │FROM │ TO  │   │ │
│   │   │[ ][C][ ][ ]│        │[ ][ ][ ][ ]│        │     │     │   │ │
│   │   └─────────────┘        └─────────────┘        │[A]  │ [A] │   │ │
│   │   ✗ Fragmented           ✓ No fragmentation    │[ ]  │ [B] │   │ │
│   │   ✓ Fast                 ✗ Slow (compaction)   │[B]  │ [C] │   │ │
│   │                                                │[ ]  │     │   │ │
│   │                                                │[C]  │     │   │ │
│   │                                                └─────┴─────┘   │ │
│   │                                                Copy live only   │ │
│   │                                                ✓ Fast + compact │ │
│   │                                                ✗ Uses 2x space  │ │
│   │                                                                   │ │
│   └──────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
```

### Reference Types

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         REFERENCE TYPES                                  │
│                                                                          │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  STRONG REFERENCE (Default)                                       │  │
│   │  ─────────────────────────────                                    │  │
│   │  Object obj = new Object();                                       │  │
│   │                                                                   │  │
│   │  • Never collected while reachable                               │  │
│   │  • Set to null to make eligible for GC                           │  │
│   │  • Most common reference type                                    │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│                        │                                                 │
│                        ▼ (weaker)                                        │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  SOFT REFERENCE                                                   │  │
│   │  ──────────────────                                               │  │
│   │  SoftReference<Object> soft = new SoftReference<>(new Object()); │  │
│   │                                                                   │  │
│   │  • Collected only when JVM is low on memory                      │  │
│   │  • Cleared BEFORE OutOfMemoryError                               │  │
│   │  • Perfect for: Memory-sensitive caches                          │  │
│   │  • Use: soft.get() - returns null if collected                   │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│                        │                                                 │
│                        ▼ (weaker)                                        │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  WEAK REFERENCE                                                   │  │
│   │  ────────────────                                                 │  │
│   │  WeakReference<Object> weak = new WeakReference<>(new Object()); │  │
│   │                                                                   │  │
│   │  • Collected at NEXT GC cycle (if no strong refs)                │  │
│   │  • Perfect for: Canonical mappings, listeners                    │  │
│   │  • WeakHashMap uses weak keys                                    │  │
│   │  • Use: weak.get() - returns null if collected                   │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│                        │                                                 │
│                        ▼ (weaker)                                        │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  PHANTOM REFERENCE                                                │  │
│   │  ─────────────────                                                │  │
│   │  ReferenceQueue<Object> queue = new ReferenceQueue<>();          │  │
│   │  PhantomReference<Object> phantom =                              │  │
│   │      new PhantomReference<>(new Object(), queue);                │  │
│   │                                                                   │  │
│   │  • get() ALWAYS returns null                                     │  │
│   │  • Enqueued AFTER object is finalized                            │  │
│   │  • Perfect for: Post-mortem cleanup, native resource cleanup    │  │
│   │  • Replaced finalize() (deprecated)                              │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│   COLLECTION ORDER:                                                     │
│   Strong → Soft (on memory pressure) → Weak (any GC) → Phantom (after) │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### G1 GC Region-Based Layout

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    G1 GC (Garbage First) - Java 9+ Default               │
│                                                                          │
│   Traditional (Serial/Parallel/CMS):      G1:                           │
│   ┌────────────────────────────────┐     ┌───┬───┬───┬───┬───┬───┐     │
│   │  Young    │      Old           │     │ E │ E │ S │ O │ O │ H │     │
│   │ [E][S][S] │    [Tenured]       │     ├───┼───┼───┼───┼───┼───┤     │
│   │           │                     │     │ O │ E │ O │ O │ H │ H │     │
│   │ Contiguous regions             │     ├───┼───┼───┼───┼───┼───┤     │
│   └────────────────────────────────┘     │ E │ O │ O │ S │ O │ E │     │
│                                          └───┴───┴───┴───┴───┴───┘     │
│                                          Non-contiguous regions         │
│                                          E=Eden, S=Survivor, O=Old      │
│                                          H=Humongous (large objects)    │
│                                                                          │
│   G1 KEY CONCEPTS:                                                      │
│   ┌──────────────────────────────────────────────────────────────────┐ │
│   │                                                                   │ │
│   │   1. HEAP DIVIDED INTO EQUAL-SIZED REGIONS (1-32MB each)        │ │
│   │      • Typically 2048 regions                                    │ │
│   │      • Region can be: Eden, Survivor, Old, Humongous, or Free   │ │
│   │                                                                   │ │
│   │   2. "GARBAGE FIRST" COLLECTION                                  │ │
│   │      • Identifies regions with most garbage                      │ │
│   │      • Collects those regions first (best ROI)                   │ │
│   │      • Predictable pause times                                   │ │
│   │                                                                   │ │
│   │   3. MIXED GC                                                    │ │
│   │      • Collects young regions + some old regions                 │ │
│   │      • Spreads old gen collection over time                      │ │
│   │                                                                   │ │
│   └──────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│   G1 PHASES:                                                            │
│   ┌──────────────────────────────────────────────────────────────────┐ │
│   │                                                                   │ │
│   │   1. Young GC (STW) ────▶ 2. Concurrent Marking ────▶            │ │
│   │      Evacuate Eden          Mark live objects                    │ │
│   │      to Survivor            (mostly concurrent)                  │ │
│   │                                     │                             │ │
│   │                                     ▼                             │ │
│   │   4. Mixed GC (STW) ◀──── 3. Remark (STW)                        │ │
│   │      Collect young +         Finalize marking                    │ │
│   │      some old regions        Handle SATB changes                 │ │
│   │                                                                   │ │
│   └──────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│   TUNING:                                                               │
│   -XX:MaxGCPauseMillis=200     # Target pause time (default 200ms)     │
│   -XX:G1HeapRegionSize=4m      # Region size (auto-calculated)         │
│   -XX:G1ReservePercent=10      # Reserve heap for allocation           │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### JIT Compilation

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    JIT COMPILATION                                       │
│                                                                          │
│   EXECUTION FLOW:                                                       │
│   ┌──────────────────────────────────────────────────────────────────┐ │
│   │                                                                   │ │
│   │   .class file (bytecode)                                         │ │
│   │          │                                                        │ │
│   │          ▼                                                        │ │
│   │   ┌──────────────────┐                                            │ │
│   │   │   INTERPRETER    │◀──────┐                                    │ │
│   │   │                  │       │                                    │ │
│   │   │ Execute bytecode │       │ Cold code                         │ │
│   │   │ line by line     │       │ (run few times)                   │ │
│   │   └────────┬─────────┘       │                                    │ │
│   │            │                 │                                    │ │
│   │            │ Profile + count │                                    │ │
│   │            │ executions      │                                    │ │
│   │            │                 │                                    │ │
│   │            ▼                 │                                    │ │
│   │   ┌──────────────────┐       │                                    │ │
│   │   │  Is code "HOT"?  │───No──┘                                    │ │
│   │   │ (> threshold)    │                                            │ │
│   │   └────────┬─────────┘                                            │ │
│   │            │ Yes                                                  │ │
│   │            ▼                                                      │ │
│   │   ┌──────────────────┐                                            │ │
│   │   │   JIT COMPILER   │                                            │ │
│   │   │                  │                                            │ │
│   │   │ Compile to       │                                            │ │
│   │   │ native code      │                                            │ │
│   │   └────────┬─────────┘                                            │ │
│   │            │                                                      │ │
│   │            ▼                                                      │ │
│   │   ┌──────────────────┐                                            │ │
│   │   │  CODE CACHE      │                                            │ │
│   │   │                  │                                            │ │
│   │   │ Store compiled   │                                            │ │
│   │   │ native code      │                                            │ │
│   │   │                  │                                            │ │
│   │   │ Future calls     │                                            │ │
│   │   │ use native code  │                                            │ │
│   │   │ directly (FAST!) │                                            │ │
│   │   └──────────────────┘                                            │ │
│   │                                                                   │ │
│   └──────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│   TIERED COMPILATION (Default):                                         │
│   ┌──────────────────────────────────────────────────────────────────┐ │
│   │  Level 0: Interpreter (slow, gathering profile data)             │ │
│   │      │                                                            │ │
│   │      ▼                                                            │ │
│   │  Level 1-3: C1 Compiler (quick compile, basic optimizations)     │ │
│   │      │                                                            │ │
│   │      ▼ (if really hot)                                           │ │
│   │  Level 4: C2 Compiler (slow compile, aggressive optimizations)   │ │
│   └──────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│   COMMON JIT OPTIMIZATIONS:                                             │
│   • Inlining: Replace method call with method body                     │
│   • Escape Analysis: Stack-allocate if object doesn't escape           │
│   • Loop Unrolling: Reduce loop overhead                               │
│   • Dead Code Elimination: Remove unreachable code                     │
│   • Lock Elision: Remove unnecessary synchronization                   │
│   • Null Check Elimination: Remove redundant null checks               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Code Examples

### 1) Memory Information

```java
public class MemoryInfo {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        
        // Memory values in bytes
        long maxMemory = runtime.maxMemory();       // -Xmx
        long totalMemory = runtime.totalMemory();   // Current heap size
        long freeMemory = runtime.freeMemory();     // Free in current heap
        long usedMemory = totalMemory - freeMemory;
        
        System.out.println("Max Memory (Xmx):   " + toMB(maxMemory) + " MB");
        System.out.println("Total Memory:       " + toMB(totalMemory) + " MB");
        System.out.println("Free Memory:        " + toMB(freeMemory) + " MB");
        System.out.println("Used Memory:        " + toMB(usedMemory) + " MB");
        
        // Available processors
        System.out.println("Processors:         " + runtime.availableProcessors());
        
        // Request garbage collection (no guarantee!)
        System.gc();  // Equivalent to: runtime.gc();
    }
    
    private static long toMB(long bytes) {
        return bytes / (1024 * 1024);
    }
}
```

### 2) Reference Types Usage

```java
import java.lang.ref.*;

public class ReferenceTypesDemo {
    public static void main(String[] args) {
        // Strong reference - normal reference
        Object strong = new Object();
        // Object won't be GC'd while 'strong' variable exists
        
        // Soft reference - cleared on memory pressure
        SoftReference<byte[]> softCache = new SoftReference<>(new byte[1024 * 1024]);
        byte[] cached = softCache.get();  // May return null if cleared
        if (cached != null) {
            System.out.println("Cache hit!");
        } else {
            System.out.println("Cache was cleared, recreating...");
            cached = new byte[1024 * 1024];
            softCache = new SoftReference<>(cached);
        }
        
        // Weak reference - cleared at next GC
        Object obj = new Object();
        WeakReference<Object> weakRef = new WeakReference<>(obj);
        obj = null;  // Remove strong reference
        
        System.gc();  // Request GC
        
        if (weakRef.get() == null) {
            System.out.println("Weak reference was cleared");
        }
        
        // Phantom reference - for cleanup after finalization
        ReferenceQueue<Object> queue = new ReferenceQueue<>();
        Object resource = new Object();
        PhantomReference<Object> phantom = new PhantomReference<>(resource, queue);
        
        // phantom.get() always returns null!
        System.out.println("Phantom get: " + phantom.get());  // null
        
        resource = null;
        System.gc();
        
        // Check queue for phantom reference (object was finalized)
        Reference<?> ref = queue.poll();
        if (ref != null) {
            System.out.println("Object was collected, perform cleanup");
            ref.clear();  // Clear the phantom reference
        }
    }
}

// Practical example: Memory-sensitive cache with SoftReferences
class SoftCache<K, V> {
    private final Map<K, SoftReference<V>> cache = new ConcurrentHashMap<>();
    
    public void put(K key, V value) {
        cache.put(key, new SoftReference<>(value));
    }
    
    public V get(K key) {
        SoftReference<V> ref = cache.get(key);
        if (ref != null) {
            V value = ref.get();
            if (value == null) {
                cache.remove(key);  // Cleanup cleared reference
            }
            return value;
        }
        return null;
    }
    
    public void clear() {
        cache.clear();
    }
}
```

### 3) Class Loading

```java
public class ClassLoadingDemo {
    public static void main(String[] args) throws Exception {
        // Get classloaders
        ClassLoader appLoader = ClassLoadingDemo.class.getClassLoader();
        ClassLoader platformLoader = appLoader.getParent();
        ClassLoader bootstrapLoader = platformLoader.getParent();
        
        System.out.println("App ClassLoader: " + appLoader);
        System.out.println("Platform ClassLoader: " + platformLoader);
        System.out.println("Bootstrap ClassLoader: " + bootstrapLoader);  // null
        
        // Which classloader loaded what?
        System.out.println("\nString loaded by: " + String.class.getClassLoader());  // null (bootstrap)
        System.out.println("ArrayList loaded by: " + java.util.ArrayList.class.getClassLoader());  // null
        System.out.println("This class loaded by: " + ClassLoadingDemo.class.getClassLoader());
        
        // Load class dynamically
        Class<?> clazz = Class.forName("java.util.HashMap");
        System.out.println("\nLoaded class: " + clazz.getName());
        
        // Check if class is loaded without loading it
        // This requires custom classloader or reflection tricks
        
        // Force initialization
        Class<?> initialized = Class.forName("com.example.MyClass", true, appLoader);
        
        // Load without initialization
        Class<?> notInitialized = Class.forName("com.example.MyClass", false, appLoader);
    }
}

// Custom ClassLoader example
class MyClassLoader extends ClassLoader {
    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        // Custom loading logic - e.g., load from network, database, etc.
        
        // For system classes, delegate to parent
        if (name.startsWith("java.") || name.startsWith("javax.")) {
            return super.loadClass(name);
        }
        
        // Load custom classes
        try {
            byte[] bytes = loadClassBytes(name);
            return defineClass(name, bytes, 0, bytes.length);
        } catch (Exception e) {
            throw new ClassNotFoundException(name, e);
        }
    }
    
    private byte[] loadClassBytes(String name) throws Exception {
        // Load .class file bytes from custom source
        String path = name.replace('.', '/') + ".class";
        try (InputStream is = getClass().getResourceAsStream("/" + path)) {
            if (is == null) throw new ClassNotFoundException(name);
            return is.readAllBytes();
        }
    }
}
```

### 4) GC Logging Analysis

```java
// JVM flags for GC logging (Java 9+):
// -Xlog:gc*:file=gc.log:time,uptime,level,tags

// Sample GC log output:
// [2024-01-15T10:30:00.123+0000][0.456s][info][gc] GC(0) Pause Young (Normal) 
//     (G1 Evacuation Pause) 24M->8M(256M) 5.234ms

// Programmatic GC notification
import com.sun.management.GarbageCollectionNotificationInfo;
import javax.management.*;
import java.lang.management.*;

public class GCMonitor {
    public static void main(String[] args) {
        // Get GC MXBeans
        for (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) {
            System.out.println("GC Name: " + gc.getName());
            System.out.println("  Collection count: " + gc.getCollectionCount());
            System.out.println("  Collection time: " + gc.getCollectionTime() + "ms");
            System.out.println("  Memory pools: " + String.join(", ", gc.getMemoryPoolNames()));
            System.out.println();
        }
        
        // Get Memory MXBean
        MemoryMXBean memory = ManagementFactory.getMemoryMXBean();
        MemoryUsage heap = memory.getHeapMemoryUsage();
        MemoryUsage nonHeap = memory.getNonHeapMemoryUsage();
        
        System.out.println("Heap Memory:");
        printMemoryUsage(heap);
        
        System.out.println("\nNon-Heap Memory (Metaspace, Code Cache):");
        printMemoryUsage(nonHeap);
        
        // Memory pool details
        System.out.println("\nMemory Pools:");
        for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {
            System.out.println("  " + pool.getName() + ": " + pool.getUsage());
        }
    }
    
    private static void printMemoryUsage(MemoryUsage usage) {
        System.out.println("  Init:      " + toMB(usage.getInit()) + " MB");
        System.out.println("  Used:      " + toMB(usage.getUsed()) + " MB");
        System.out.println("  Committed: " + toMB(usage.getCommitted()) + " MB");
        System.out.println("  Max:       " + toMB(usage.getMax()) + " MB");
    }
    
    private static long toMB(long bytes) {
        return bytes / (1024 * 1024);
    }
}
```

### 5) Memory Leak Examples

```java
// LEAK 1: Static collection that keeps growing
public class StaticCollectionLeak {
    private static final List<Object> cache = new ArrayList<>();
    
    public void addToCache(Object obj) {
        cache.add(obj);  // Never removed!
    }
    
    // FIX: Use bounded cache or weak references
    private static final Map<String, SoftReference<Object>> fixedCache = 
        new ConcurrentHashMap<>();
}

// LEAK 2: Unclosed resources
public class ResourceLeak {
    public void query() throws SQLException {
        Connection conn = dataSource.getConnection();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM users");
        // If exception here, connection never closed!
        conn.close();
    }
    
    // FIX: Use try-with-resources
    public void queryFixed() throws SQLException {
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT * FROM users")) {
            // Process results
        }  // Auto-closed
    }
}

// LEAK 3: Inner class holding outer reference
public class InnerClassLeak {
    private byte[] largeData = new byte[10_000_000];
    
    public Runnable createTask() {
        return new Runnable() {  // Holds reference to InnerClassLeak.this
            public void run() {
                System.out.println("Task running");
                // largeData can't be GC'd even if not used!
            }
        };
    }
    
    // FIX: Use static inner class or lambda
    public Runnable createTaskFixed() {
        return () -> System.out.println("Task running");  // No outer reference
    }
}

// LEAK 4: ThreadLocal not cleaned in thread pool
public class ThreadLocalLeak {
    private static final ThreadLocal<HeavyObject> cache = new ThreadLocal<>();
    
    public void handleRequest() {
        cache.set(new HeavyObject());
        try {
            // Process request
        } finally {
            cache.remove();  // IMPORTANT! Clean up in thread pool
        }
    }
}

// LEAK 5: Listeners not removed
public class ListenerLeak {
    public void setupUI() {
        button.addActionListener(e -> handleClick());
        // If this object is discarded but button persists,
        // listener keeps reference to this object!
    }
    
    // FIX: Remove listeners when done
    public void cleanup() {
        button.removeActionListener(listener);
    }
}
```

---

## Interview Questions with Answers

### JVM Memory

**1. Explain the different memory areas in JVM.**

The JVM has several memory areas:
- **Heap**: Shared memory for all objects. Divided into Young (Eden + Survivors) and Old generations.
- **Stack**: Per-thread memory for method execution. Stores local variables, method parameters, return addresses.
- **Metaspace**: Stores class metadata (replaced PermGen in Java 8). Uses native memory.
- **PC Register**: Per-thread, holds address of current instruction.
- **Native Method Stack**: Per-thread, for native (C/C++) method calls.

**2. What is the difference between stack and heap?**

| Stack | Heap |
|-------|------|
| Per-thread (isolated) | Shared across threads |
| Stores primitives, references, frames | Stores objects |
| LIFO, fast access | Dynamic, slower |
| Fixed size (-Xss) | Growable (-Xms/-Xmx) |
| Auto cleanup on method exit | Garbage collected |
| StackOverflowError | OutOfMemoryError |

**3. What is Metaspace? How is it different from PermGen?**

Metaspace replaced PermGen in Java 8:
- Uses native memory (not JVM heap)
- Can grow dynamically (configurable limit)
- Less prone to OutOfMemoryError
- Stores class metadata, method info, constant pools
- Garbage collected when classloaders are unloaded

### Garbage Collection

**4. What is garbage collection and why do we need it?**

GC is automatic memory management that reclaims memory from unreachable objects:
- Prevents memory leaks (objects no longer needed)
- Developers don't need to manually free memory
- Prevents dangling pointer bugs
- Trade-off: CPU overhead and occasional pauses

**5. Explain the generational hypothesis.**

"Most objects die young" - observation that majority of objects have very short lifetimes.

Strategy:
- **Young Generation**: Frequent, fast GC (Minor GC). Most objects collected here.
- **Old Generation**: Infrequent, slower GC. For long-lived objects.
- Objects surviving multiple Minor GCs are promoted to Old gen.

**6. What are GC roots?**

Starting points for reachability analysis:
- Local variables on active thread stacks
- Static fields of loaded classes
- Active threads themselves
- JNI references
- Monitors/locks held

**7. Compare Serial, Parallel, G1, and ZGC collectors.**

| Collector | Threads | Use Case | Pause |
|-----------|---------|----------|-------|
| Serial | Single | Small heaps, client apps | Long STW |
| Parallel | Multi | Throughput, batch jobs | Long STW |
| G1 | Multi | Balanced, default Java 9+ | Predictable |
| ZGC | Multi | Ultra-low latency | < 10ms |

### Advanced

**8. What is JIT compilation? What optimizations does it perform?**

JIT (Just-In-Time) compilation converts "hot" bytecode to native machine code at runtime.

Optimizations:
- **Inlining**: Replace method call with method body
- **Escape Analysis**: Stack-allocate non-escaping objects
- **Loop Unrolling**: Reduce loop overhead
- **Dead Code Elimination**: Remove unreachable code
- **Lock Elision**: Remove unnecessary synchronization

**9. How do you detect memory leaks in Java?**

1. **Monitor heap growth** over time (should be stable)
2. **Heap dump analysis** with Eclipse MAT or VisualVM
3. **Look for**: Growing collections, unexpected retention, many instances of same class
4. **GC logs**: Frequent Full GCs, increasing old gen usage
5. **Profiling**: JFR, async-profiler

**10. What causes OutOfMemoryError and how do you fix each?**

- **"Java heap space"**: Increase -Xmx, check for leaks
- **"GC overhead limit"**: GC taking >98% time, increase heap or fix leak
- **"Metaspace"**: Too many classes, increase -XX:MaxMetaspaceSize
- **"Direct buffer"**: NIO buffers, increase -XX:MaxDirectMemorySize
- **"Unable to create native thread"**: Too many threads, reduce -Xss

---

## Quick Reference: JVM Flags

```bash
# MEMORY SIZING
-Xms4g                        # Initial heap size
-Xmx8g                        # Maximum heap size
-Xmn2g                        # Young generation size
-Xss1m                        # Thread stack size
-XX:MetaspaceSize=256m        # Initial metaspace
-XX:MaxMetaspaceSize=512m     # Max metaspace
-XX:MaxDirectMemorySize=256m  # Max direct buffer memory

# GC SELECTION
-XX:+UseG1GC                  # G1 (default Java 9+)
-XX:+UseZGC                   # ZGC (Java 11+, production Java 15+)
-XX:+UseShenandoahGC          # Shenandoah
-XX:+UseParallelGC            # Parallel/Throughput
-XX:+UseSerialGC              # Serial (single-threaded)

# G1 TUNING
-XX:MaxGCPauseMillis=200      # Target pause time (default 200ms)
-XX:G1HeapRegionSize=4m       # Region size (1-32MB)
-XX:G1ReservePercent=10       # Reserved for allocation
-XX:+G1UseAdaptiveIHOP        # Adaptive marking threshold

# GC LOGGING (Java 9+)
-Xlog:gc*:file=gc.log:time,uptime,level,tags
-Xlog:gc:stdout:time          # Console output

# DIAGNOSTICS
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/dump.hprof
-XX:OnOutOfMemoryError="kill -9 %p"
-XX:NativeMemoryTracking=summary

# PERFORMANCE
-XX:+UseCompressedOops        # Compress pointers (default < 32GB heap)
-XX:ReservedCodeCacheSize=256m
-XX:+TieredCompilation        # Enable tiered compilation (default)
-XX:CompileThreshold=10000    # Compilation threshold

# DEBUG/ANALYSIS
-XX:+PrintFlagsFinal          # Show all JVM flags
-XX:+PrintCompilation         # Show JIT compilation
-Xint                         # Disable JIT (debug only)
```

---

## Memory Troubleshooting Flowchart

```
OutOfMemoryError
       │
       ├── "Java heap space"
       │   ├── Check for memory leaks (heap dump analysis)
       │   ├── Increase -Xmx if legitimate usage
       │   └── Optimize object creation/retention
       │
       ├── "GC overhead limit exceeded"
       │   ├── GC taking >98% time, recovering <2% memory
       │   ├── Likely severe memory leak
       │   └── Analyze heap dump, fix leak or increase heap
       │
       ├── "Metaspace"
       │   ├── Too many classes loaded
       │   ├── Classloader leak (common in app servers)
       │   └── Increase -XX:MaxMetaspaceSize or fix leak
       │
       ├── "Direct buffer memory"
       │   ├── NIO ByteBuffer.allocateDirect() issue
       │   └── Increase -XX:MaxDirectMemorySize
       │
       ├── "Unable to create new native thread"
       │   ├── Too many threads (check thread dump)
       │   ├── OS ulimit restrictions
       │   └── Reduce -Xss or fix thread leak
       │
       └── "Requested array size exceeds VM limit"
           └── Attempting to allocate array > 2^31-1 elements
```
